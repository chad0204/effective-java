46. 全排列（中等）
47. 全排列 II（中等）：思考为什么造成了重复，如何在搜索之前就判断这一支会产生重复；
39. 组合总和（中等）
40. 组合总和 II（中等）
77. 组合（中等）
78. 子集（中等）
90. 子集 II（中等）：剪枝技巧同 47 题、39 题、40 题；

60. 第 k 个排列（中等）：利用了剪枝的思想，减去了大量枝叶，直接来到需要的叶子结点；
93. 复原 IP 地址（中等）




#dfs
如何解决是否能使用多次、是否包含重复元素、子集排列顺序不同的问题


46 全排列
元素只能用一次used

全排列（有重复元素）
只能用一次used 如 aaa bbb
跳过重复元素sort+ [i]==[i-1] + !used[i-1] 如 abb abb

子集
元素只能用一次used
过滤顺序不同元素相同的子集 begin=depth 如 abc:acb, ab:ba

子集（有重复元素）
元素只能用一次used
跳过重复元素sort+ [i]==[i-1] + !used[i-1]
过滤顺序不同元素相同的子集 begin=depth

组合求和 
剪枝sort+ target-nums[i]<0
过滤顺序不同元素相同的子集 begin=depth

组合求和（有重复值）
剪枝sort+ target-nums[i]<0
元素只能用一次used
跳过重复元素sort ,nums[i]==nums[i-1] && !used[i-1]
过滤顺序不同元素相同的子集 begin=depth 


