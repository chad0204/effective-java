package com.pc.algorithm.dp.knapsack;


/**
 *
 *
 * 01背包问题
 *
 * i-1表示物品编号 w[i-1] 重量 v[i-1] 价值
 * j-1表示背包承载重量
 *
 *
 *  子问题
 *  装不下的话，就是这个商品不装，取值还是装到上一个商品的最大价值
 *  dp[i][j] = dp[i-1][j]
 *
 *  装得下,取下面两种情况的最大值
 *  1.装，当前商品的价值+"背包减去当前商品重量后的重量后" 装到的商品的最大价值
 *  v[i-1] + dp[i-1][j-w[i-1]]
 *  2.不装，装到上一个商品的最大价值
 *  dp[i-1][j]
 *
 *  base case
 *  背包容量为0，0
 *  没有商品，0
 *
 *  w val   dp  0  1  2  3  4  5  6  7
 *
 *          0   0  0  0  0  0  0  0  0
 *
 *  1  1    1   0  1  1  1  1  1  1  1
 *
 *  4  3    2   0  1  1  4  4  5  5  5
 *
 *  5  4    3   0  1  1  4  5  6  6  9
 *
 *  7  5    4   0  1  1  4  5  7  8  9
 *
 *
 *
 * @author pengchao
 * @date 21:46 2021-02-10
 */
public class KnapsackOf01 {


    /**
     *
     *  牛客网
     *  vw[i][0] 体积
     *  vw[i][1] 重量
     *
     * @param V
     * @param n
     * @param vw
     * @return
     */
    public int knapsack (int V, int n, int[][] vw) {
        // write code here
        int[][] dp = new int[n+1][V+1];

        for(int i=1;i<=n;i++) {

            for(int j=1;j<=V;j++) {
//                //没商品
//                if(i==0) {
//                    dp[i][j] = 0;
//                    continue;
//                }
//                //没有体积
//                if(j==0) {
//                    dp[i][j] = 0;
//                    continue;
//                }

                if(j-vw[i-1][0] < 0) {
                    //装不了
                    dp[i][j] = dp[i-1][j];
                } else {
                    dp[i][j] = Math.max(vw[i-1][1]+dp[i-1][j-vw[i-1][0]],dp[i-1][j]);
                }
            }
        }
        return dp[n][V];

    }

    /**
     *
     *
     * 416. 分割等和子集
     *
     * 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
     *
     * 注意:
     *
     * 每个数组中的元素不会超过 100
     * 数组的大小不会超过 200
     * 示例 1:
     *
     * 输入: [1, 5, 11, 5]
     *
     * 输出: true
     *
     * 解释: 数组可以分割成 [1, 5, 5] 和 [11].
     *
     *
     * 转化成01问题，将nums求和除于2，判断数组中是否存在某些数的和正好等于该值。
     *
     *
     * 01背包问题考虑的是选取的物品的总重量不超过 背包承重
     * 该题考虑的是，选取的物品总重量 刚好等于 背包的承重
     *
     *
     *  子问题
     *  装不下，就是这个商品不装，装到上一个商品的最大价值
     *  dp[i][j] = dp[i-1][j]
     *
     *  装得下,下面两种情况一种成立，则为true
     *  1.装，如果在 i-1个商品中就已经存在一部分商品，满足他们的和等于 j-nums[i-1]
     *    dp[i-1][j-nums[i-1]]
     *  2.不装，如果在 i-1个商品中就已经存在一部分商品，满足他们的和等于 j
     *    dp[i-1][j]
     *
     *
     *
     *
     *  base case
     *  背包容量为0,肯定能装满 true
     *  没有商品，肯定装不满 false
     *
     *  nums dp  0  1  2  3  4  5  6  7
     *
     *       0   f  f  f  f  f  f  f  f
     *
     *  1    1   t  t  f  f  f  f  f  f
     *
     *  5    2   t  t  f  f  f  t  t  f
     *
     *  11   3   t  t
     *
     *  5    4   t  t
     *
     */
}
