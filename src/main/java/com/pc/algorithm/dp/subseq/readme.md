子序列问题的最大特点是，子序列是不连续的！

### 第一类：
dp[i]表示以i为结尾的结果，最后遍历dp[i]取出最值

####53.最大子序和（简单）

子数组是连续的，但是组成各种和的子数组直接不是连续的
nums[i]可能为负值


dp[i] 表示以 nums[i] '这个数结尾'的最大子序列
动态转移方程，dp[i-1]中最大的连续和是s，那么如果i和组成s的子数组相邻，则加上nums[i]，否则nums[i]自成一派，取最大值
```
dp[i] = max(dp[i-1]+nums[i],nums[i])
dp[0] = nums[0]
```
由于nums[i]可能为负值，导致结果不一定是dp[len]，要遍历求最大值



####300. 最长递增子序列（中等）


动态转移方程，dp[i] 表示以 nums[i] '这个数结尾'的最长递增子序列的长度，就是找出nums[i]>nums[j]的dp[j]
```
for(j<i) {
    dp[i] = max{dp[j]+1,dp[i]} (0<=j<i,nums[i]>nums[j])
}
dp[i] = 1  dp[i]初始值为1

```



### 第二类：

两个字符串

####1143.最长公共子序列（中等）

dp[i][j]表示两个字符串到i，j时，最长的公共子序列
```
if(s(i-1)==s(j-1)) {
    dp[i][j] = dp[i-1][j-1]+1; 
} else {
    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
}

```

####583. 两个字符串的删除操作（中等）,712.两个字符串的最小ASCII删除和（中等）


```
if(s(i-1)==s(j-1)) {
    dp[i][j] = dp[i-1][j-1];
} else {
    //任意删一个
    dp[i][j] = min(dp[i-1][j],dp[i][j-1])+1;
}

```


####72.编辑距离（困难）

```
if(s(i-1)==s(j-1)) {
    dp[i][j] = dp[i-1][j-1];
} else {
    //增删改
    dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1;
}

dp[0][j] = j,dp[i][0] = i

```

### 第三类

一个字符串，二维数组解决


516.最长回文子序列（中等）

dp[i][j] 表示s[i,..,j]之间最长的回文子序列
```
if(s[i] == s[j]) {
    dp[i][j] = dp[i+1][j-1]+2;
} else {
    dp[i][j] = max(dp[i+1][j],dp[i][j-1]);
}

dp[i][j]=1,j==i
dp[i][j]=0,j<i

```