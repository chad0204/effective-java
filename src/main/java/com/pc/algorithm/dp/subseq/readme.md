子序列问题的最大特点是，子序列是不连续的！

### 第一类：
dp[n]不是最终结果，最后遍历dp[]取出最值

####53.最大子序和（简单）

注意这个连续，子数组是连续的，但是组成各种和的子数组直接不是连续的
nums[i]可能为负值

nums[i]为正数，加入到之前的序列
nums[i]为负数，已经不是连续的最大的序列和了，只能另起炉灶重新构建连续子序列。

dp[i] 表示以 nums[i] '这个数结尾'的连续子序列和
```
dp[i] = max(dp[i-1]+nums[i],nums[i])
dp[0] = nums[0]
```
由于nums[i]可能为负值，导致结果不一定是dp[len]，要遍历求最大值



####300. 最长递增子序列（中等）


动态转移方程，dp[i] 表示以 nums[i] '这个数结尾'的最长递增子序列的长度，就是找出nums[i]>nums[j]的所有dp[j]，取最大的dp[j]
找出所有索引小于i,且值比nums[i]小的递增子序列长度dp[j]，然后取最长的一个
```
for(j<i) {
    dp[i] = max{dp[j]+1,dp[i]} (0<=j<i,nums[i]>nums[j])
}
dp[i] = 1  dp[i]初始值为1

```



### 第二类：

两个字符串

####1143.最长公共子序列（中等）

dp[i][j]表示两个字符串下标分别到i，j时，最长的公共子序列

如果Si == Tj,那么当前公共子序列为dp[i-1][j-1]的基础上加一
如果Si != Tj,有两种情况，取最大值
1.Si是，Tj不是，dp[i-1][j]
2.Si不是，Tj是，dp[i][j-1]



```
if(s(i-1)==s(j-1)) {
    dp[i][j] = dp[i-1][j-1]+1; 
} else {
    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
}

```

####583. 两个字符串的删除操作（中等）,712.两个字符串的最小ASCII删除和（中等）


```
if(s(i-1)==s(j-1)) {
    dp[i][j] = dp[i-1][j-1];
} else {
    //任意删一个
    dp[i][j] = min(dp[i-1][j],dp[i][j-1])+1;
}

```


####72.编辑距离（困难）

```
if(s(i-1)==s(j-1)) {
    dp[i][j] = dp[i-1][j-1];
} else {
    //增删改
    dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1;
}

dp[0][j] = j,dp[i][0] = i

```

### 第三类

一个字符串，二维数组解决


516.最长回文子序列（中等）

dp[i][j] 表示s[i,..,j]之间最长的回文子序列

s[i]==s[j] ,说明dp[i][j] = dp[i+1][j-1]+2
s[i]!=s[j]，两种可能取最大值
i是回文，dp[i][j-1]
j是回文，dp[i+1][j]

```
if(s[i] == s[j]) {
    dp[i][j] = dp[i+1][j-1]+2;
} else {
    dp[i][j] = max(dp[i+1][j],dp[i][j-1]);
}

dp[i][j]=1,j==i
dp[i][j]=0,j<i

```